function mlapp2m(listOfMLAPPFiles, showDiffApp)
    arguments
        listOfMLAPPFiles cell = {'winDriveTest', 'winSignalAnalysis', 'winRFDataHub'};
        showDiffApp   logical = false
    end

    fileFolder = fileparts(mfilename('fullpath'));

    % Trata-se de manipulação no arquivo .MLAPP de módulo do appAnalise,
    % criando uma versão editada do arquivo .M, de forma que seja possível
    % renderizá-lo em container do próprio appAnalise.
    
    Step2Pattern  = sprintf(['function createComponents(app, Container)\n\n'                          ...
        '            %% Create UIFigure and hide until all components are created\n'                  ...
        '            if isempty(Container)\n'                                                         ...
        '                app.UIFigure = uifigure(''Visible'', ''off'');\n'                            ...
        '                app.UIFigure.AutoResizeChildren = ''off'';\n'                                ...
        '                app.UIFigure.Position = [100 100 1244 660];\n'                               ...
        '                app.UIFigure.Name = ''appAnalise'';\n'                                       ...
        '                app.UIFigure.Icon = ''icon_48.png'';\n'                                      ...
        '                app.UIFigure.CloseRequestFcn = createCallbackFcn(app, @closeFcn, true);\n\n' ...
        '                app.Container = app.UIFigure;\n\n'                                           ...
        '            else\n'                                                                          ...
        '                delete(Container.Children)\n\n'                                              ...
        '                app.UIFigure  = ancestor(Container, ''figure'');\n'                          ...
        '                app.Container = Container;\n'                                                ...
        '                app.isDocked  = true;\n'                                                     ...
        '            end\n\n'                                                                         ...
        '            %% Create GridLayout\n'                                                          ...
        '            app.GridLayout = uigridlayout(app.Container);']);
    
    try
        for ii = 1:numel(listOfMLAPPFiles)
            oldClassName = listOfMLAPPFiles{ii};
            newClassName = [oldClassName '_exported'];
            fileBaseName = fullfile(fileFolder, oldClassName);

            readerObj    = appdesigner.internal.serialization.FileReader([fileBaseName '.mlapp']);
            matlabCode   = readerObj.readMATLABCodeText();
            writematrix(matlabCode, fullfile(tempdir, [oldClassName '.m']), 'FileType', 'text', 'WriteMode', 'overwrite', 'QuoteStrings', 'none')
        
            % PADRÕES ARQUIVOS DE ENTRADA
            Step1_Tag1   = sprintf('classdef %s < matlab.apps.AppBase', oldClassName);
            Step2_Tag1   = 'function createComponents(app)';
            Step2_Tag2   = 'app.GridLayout = uigridlayout(app.UIFigure);';
            Step3_Tag1   = sprintf('function app = %s(varargin)', oldClassName);
        
            % VALIDAÇÃO
            if any(cellfun(@(x) ~contains(matlabCode, x), {Step1_Tag1, Step2_Tag1, Step2_Tag2, Step3_Tag1}))
                error('Não identificado uma das tags! :(')
            end
        
            % SUBSTITUIÇÃO 1: ClassName
            Step1Pattern = sprintf('classdef %s < matlab.apps.AppBase', newClassName);
            matlabCode   = replace(matlabCode, Step1_Tag1, Step1Pattern);
        
            % SUBSTITUIÇÃO 2: CreateComponents
            matlabCode   = replace(matlabCode, extractBetween(matlabCode, Step2_Tag1, Step2_Tag2, 'Boundaries', 'inclusive'), Step2Pattern);
        
            % SUBSTITUIÇÃO 3: Constructor+Delete
            Step3Pattern = sprintf(['function app = %s(Container, varargin)\n\n'         ...
                '            %% Create UIFigure and components\n'                        ...
                '            createComponents(app, Container)\n\n'                       ...
                '            %% Execute the startup function\n'                          ...
                '            runStartupFcn(app, @(app)startupFcn(app, varargin{:}))\n\n' ...
                '            if nargout == 0\n'                                          ...
                '                clear app\n'                                            ...
                '            end\n'                                                      ...
                '        end\n\n'                                                        ...
                '        %% Code that executes before app deletion\n'                    ...
                '        function delete(app)\n\n'                                       ...
                '            %% Delete UIFigure when app is deleted\n'                   ...
                '            if ~app.isDocked\n'                                         ...                
                '                delete(app.UIFigure)\n'                                 ...
                '            end\n'                                                      ...
                '        end\n'                                                          ...
                '    end\n'                                                              ...
                'end'], newClassName);
            matlabCode   = replace(matlabCode, [Step3_Tag1 extractAfter(matlabCode, Step3_Tag1)], Step3Pattern);

            % ARQUIVO DE SAÍDA
            writematrix(matlabCode, [fileBaseName '_exported.m'], 'FileType', 'text', 'WriteMode', 'overwrite', 'QuoteStrings', 'none')
            fprintf('Criado o arquivo %s\n', [fileBaseName '_exported.m'])

            if showDiffApp
                visdiff(fullfile(tempdir, [oldClassName '.m']), [fileBaseName '_exported.m'])
            end
        end

    catch ME
        fprintf('ERRO ao processar o arquivo %s. %s\n', [fileBaseName '.mlapp'], ME.message)
    end
end